"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/rest
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
/**
 * Writes the result from Application controller method
 * into the HTTP response
 *
 * @param response HTTP Response
 * @param result Result from the API to write into HTTP Response
 */
function writeResultToResponse(
// not needed and responsibility should be in the sequence.send
response, 
// result returned back from invoking controller method
result) {
    if (result) {
        if (result instanceof stream_1.Readable || typeof result.pipe === 'function') {
            response.setHeader('Content-Type', 'application/octet-stream');
            // Stream
            result.pipe(response);
            return;
        }
        switch (typeof result) {
            case 'object':
            case 'boolean':
            case 'number':
                if (Buffer.isBuffer(result)) {
                    // Buffer for binary data
                    response.setHeader('Content-Type', 'application/octet-stream');
                }
                else {
                    // TODO(ritch) remove this, should be configurable
                    // See https://github.com/strongloop/loopback-next/issues/436
                    response.setHeader('Content-Type', 'application/json');
                    // TODO(bajtos) handle errors - JSON.stringify can throw
                    result = JSON.stringify(result);
                }
                break;
            default:
                response.setHeader('Content-Type', 'text/plain');
                result = result.toString();
                break;
        }
        response.write(result);
    }
    response.end();
}
exports.writeResultToResponse = writeResultToResponse;
/**
 * Write an error into the HTTP response
 * @param response HTTP response
 * @param error Error
 */
function writeErrorToResponse(response, error) {
    const e = error;
    const statusCode = (response.statusCode = e.statusCode || e.status || 500);
    if (e.headers) {
        // Set response headers for the error
        for (const h in e.headers) {
            response.setHeader(h, e.headers[h]);
        }
    }
    // Build an error object
    const errObj = {
        statusCode,
    };
    if (e.expose) {
        // Expose other properties if the `expose` flag is set to `true`
        for (const p in e) {
            if (p === 'headers' ||
                p === 'expose' ||
                p === 'status' ||
                p === 'statusCode')
                continue;
            errObj[p] = e[p];
        }
    }
    response.setHeader('Content-Type', 'application/json');
    response.write(JSON.stringify(errObj));
    response.end();
}
exports.writeErrorToResponse = writeErrorToResponse;
//# sourceMappingURL=writer.js.map