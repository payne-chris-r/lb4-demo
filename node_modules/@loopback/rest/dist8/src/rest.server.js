"use strict";
// Copyright IBM Corp. 2017,2018. All Rights Reserved.
// Node module: @loopback/rest
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = require("assert");
const js_yaml_1 = require("js-yaml");
const context_1 = require("@loopback/context");
const routing_table_1 = require("./router/routing-table");
const http_server_1 = require("@loopback/http-server");
const cors = require("cors");
const core_1 = require("@loopback/core");
const openapi_v3_1 = require("@loopback/openapi-v3");
const http_handler_1 = require("./http-handler");
const sequence_1 = require("./sequence");
const keys_1 = require("./keys");
const express = require("express");
const debug = require('debug')('loopback:rest:server');
const SequenceActions = keys_1.RestBindings.SequenceActions;
// NOTE(bajtos) we cannot use `import * as cloneDeep from 'lodash/cloneDeep'
// because it produces the following TypeScript error:
//  Module '"(...)/node_modules/@types/lodash/cloneDeep/index"' resolves to
//  a non-module entity and cannot be imported using this construct.
const cloneDeep = require('lodash/cloneDeep');
const OPENAPI_SPEC_MAPPING = {
    '/openapi.json': { version: '3.0.0', format: 'json' },
    '/openapi.yaml': { version: '3.0.0', format: 'yaml' },
};
/**
 * A REST API server for use with Loopback.
 * Add this server to your application by importing the RestComponent.
 * ```ts
 * const app = new MyApplication();
 * app.component(RestComponent);
 * ```
 *
 * To add additional instances of RestServer to your application, use the
 * `.server` function:
 * ```ts
 * app.server(RestServer, 'nameOfYourServer');
 * ```
 *
 * By default, one instance of RestServer will be created when the RestComponent
 * is bootstrapped. This instance can be retrieved with
 * `app.getServer(RestServer)`, or by calling `app.get('servers.RestServer')`
 * Note that retrieving other instances of RestServer must be done using the
 * server's name:
 * ```ts
 * const server = await app.getServer('foo')
 * // OR
 * const server = await app.get('servers.foo');
 * ```
 *
 * @export
 * @class RestServer
 * @extends {Context}
 * @implements {Server}
 */
let RestServer = class RestServer extends context_1.Context {
    /**
     * @memberof RestServer
     * Creates an instance of RestServer.
     *
     * @param {Application} app The application instance (injected via
     * CoreBindings.APPLICATION_INSTANCE).
     * @param {RestServerConfig=} options The configuration options (injected via
     * RestBindings.CONFIG).
     *
     */
    constructor(app, options) {
        super(app);
        options = options || {};
        // Can't check falsiness, 0 is a valid port.
        if (options.port == null) {
            options.port = 3000;
        }
        if (options.host == null) {
            // Set it to '' so that the http server will listen on all interfaces
            options.host = undefined;
        }
        this.bind(keys_1.RestBindings.PORT).to(options.port);
        this.bind(keys_1.RestBindings.HOST).to(options.host);
        this.bind(keys_1.RestBindings.PROTOCOL).to(options.protocol || 'http');
        this.bind(keys_1.RestBindings.HTTPS_OPTIONS).to(options);
        if (options.sequence) {
            this.sequence(options.sequence);
        }
        this._setupRequestHandler(options);
        this.bind(keys_1.RestBindings.HANDLER).toDynamicValue(() => this.httpHandler);
    }
    get httpHandler() {
        this._setupHandlerIfNeeded();
        return this._httpHandler;
    }
    get listening() {
        return this._httpServer ? this._httpServer.listening : false;
    }
    get url() {
        return this._httpServer && this._httpServer.url;
    }
    _setupRequestHandler(options) {
        this._expressApp = express();
        this.requestHandler = this._expressApp;
        // Allow CORS support for all endpoints so that users
        // can test with online SwaggerUI instance
        const corsOptions = options.cors || {
            origin: '*',
            methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
            preflightContinue: false,
            optionsSuccessStatus: 204,
            maxAge: 86400,
            credentials: true,
        };
        this._expressApp.use(cors(corsOptions));
        // Mount our router & request handler
        this._expressApp.use((req, res, next) => {
            this._handleHttpRequest(req, res, options).catch(next);
        });
        // Mount our error handler
        this._expressApp.use((err, req, res, next) => {
            this._onUnhandledError(req, res, err);
        });
    }
    _handleHttpRequest(request, response, options) {
        if (request.method === 'GET' &&
            request.url &&
            request.url in OPENAPI_SPEC_MAPPING) {
            // NOTE(bajtos) Regular routes are handled through Sequence.
            // IMO, this built-in endpoint should not run through a Sequence,
            // because it's not part of the application API itself.
            // E.g. if the app implements access/audit logs, I don't want
            // this endpoint to trigger a log entry. If the server implements
            // content-negotiation to support XML clients, I don't want the OpenAPI
            // spec to be converted into an XML response.
            const settings = OPENAPI_SPEC_MAPPING[request.url];
            return this._serveOpenApiSpec(request, response, settings);
        }
        if (request.method === 'GET' &&
            request.url &&
            request.url === '/swagger-ui') {
            return this._redirectToSwaggerUI(request, response, options);
        }
        return this.httpHandler.handleRequest(request, response);
    }
    _setupHandlerIfNeeded() {
        // TODO(bajtos) support hot-reloading of controllers
        // after the app started. The idea is to rebuild the HttpHandler
        // instance whenever a controller was added/deleted.
        // See https://github.com/strongloop/loopback-next/issues/433
        if (this._httpHandler)
            return;
        this._httpHandler = new http_handler_1.HttpHandler(this);
        for (const b of this.find('controllers.*')) {
            const controllerName = b.key.replace(/^controllers\./, '');
            const ctor = b.valueConstructor;
            if (!ctor) {
                throw new Error(`The controller ${controllerName} was not bound via .toClass()`);
            }
            const apiSpec = openapi_v3_1.getControllerSpec(ctor);
            if (!apiSpec) {
                // controller methods are specified through app.api() spec
                debug('Skipping controller %s - no API spec provided', controllerName);
                continue;
            }
            debug('Registering controller %s', controllerName);
            if (apiSpec.components && apiSpec.components.schemas) {
                this._httpHandler.registerApiDefinitions(apiSpec.components.schemas);
            }
            const controllerFactory = routing_table_1.createControllerFactoryForBinding(b.key);
            this._httpHandler.registerController(apiSpec, ctor, controllerFactory);
        }
        for (const b of this.find('routes.*')) {
            // TODO(bajtos) should we support routes defined asynchronously?
            const route = this.getSync(b.key);
            this._httpHandler.registerRoute(route);
        }
        // TODO(bajtos) should we support API spec defined asynchronously?
        const spec = this.getSync(keys_1.RestBindings.API_SPEC);
        for (const path in spec.paths) {
            for (const verb in spec.paths[path]) {
                const routeSpec = spec.paths[path][verb];
                this._setupOperation(verb, path, routeSpec);
            }
        }
    }
    _setupOperation(verb, path, spec) {
        const handler = spec['x-operation'];
        if (typeof handler === 'function') {
            // Remove a field value that cannot be represented in JSON.
            // Start by creating a shallow-copy of the spec, so that we don't
            // modify the original spec object provided by user.
            spec = Object.assign({}, spec);
            delete spec['x-operation'];
            const route = new routing_table_1.Route(verb, path, spec, handler);
            this._httpHandler.registerRoute(route);
            return;
        }
        const controllerName = spec['x-controller-name'];
        if (typeof controllerName === 'string') {
            const b = this.find(`controllers.${controllerName}`)[0];
            if (!b) {
                throw new Error(`Unknown controller ${controllerName} used by "${verb} ${path}"`);
            }
            const ctor = b.valueConstructor;
            if (!ctor) {
                throw new Error(`The controller ${controllerName} was not bound via .toClass()`);
            }
            const controllerFactory = routing_table_1.createControllerFactoryForBinding(b.key);
            const route = new routing_table_1.ControllerRoute(verb, path, spec, ctor, controllerFactory);
            this._httpHandler.registerRoute(route);
            return;
        }
        throw new Error(`There is no handler configured for operation "${verb} ${path}`);
    }
    async _serveOpenApiSpec(request, response, options) {
        options = options || { version: '3.0.0', format: 'json' };
        let specObj = this.getApiSpec();
        if (options.format === 'json') {
            const spec = JSON.stringify(specObj, null, 2);
            response.setHeader('content-type', 'application/json; charset=utf-8');
            response.end(spec, 'utf-8');
        }
        else {
            const yaml = js_yaml_1.safeDump(specObj, {});
            response.setHeader('content-type', 'text/yaml; charset=utf-8');
            response.end(yaml, 'utf-8');
        }
    }
    /**
     * Get the URL of the request sent by the client
     * @param request Http request
     */
    _getUrlForClient(request, options) {
        const protocol = (request.get('x-forwarded-proto') || '').split(',')[0] ||
            request.protocol ||
            options.protocol ||
            'http';
        let host = (request.get('x-forwarded-host') || '').split(',')[0] ||
            request.headers.host.replace(/:[0-9]+/, '');
        let port = (request.get('x-forwarded-port') || '').split(',')[0] ||
            options.port ||
            (request.headers.host.match(/:([0-9]+)/) || [])[1] ||
            '';
        // clear default ports
        port = protocol === 'https' && port === '443' ? '' : port;
        port = protocol === 'http' && port === '80' ? '' : port;
        // add port number of present
        host += port !== '' ? ':' + port : '';
        return protocol + '://' + host;
    }
    async _redirectToSwaggerUI(request, response, options) {
        const baseUrl = options.apiExplorerUrl || 'https://loopback.io/api-explorer';
        const openApiUrl = `${this._getUrlForClient(request, options)}/openapi.json`;
        const fullUrl = `${baseUrl}?url=${openApiUrl}`;
        response.redirect(308, fullUrl);
    }
    /**
     * Register a controller class with this server.
     *
     * @param {Constructor} controllerCtor The controller class
     * (constructor function).
     * @returns {Binding} The newly created binding, you can use the reference to
     * further modify the binding, e.g. lock the value to prevent further
     * modifications.
     *
     * ```ts
     * class MyController {
     * }
     * app.controller(MyController).lock();
     * ```
     *
     */
    controller(controllerCtor) {
        return this.bind('controllers.' + controllerCtor.name).toClass(controllerCtor);
    }
    route(routeOrVerb, path, spec, controllerCtor, controllerFactory, methodName) {
        if (typeof routeOrVerb === 'object') {
            const r = routeOrVerb;
            // Encode the path to escape special chars
            const encodedPath = encodeURIComponent(r.path).replace(/\./g, '%2E');
            return this.bind(`routes.${r.verb} ${encodedPath}`)
                .to(r)
                .tag('route');
        }
        if (!path) {
            throw new assert_1.AssertionError({
                message: 'path is required for a controller-based route',
            });
        }
        if (!spec) {
            throw new assert_1.AssertionError({
                message: 'spec is required for a controller-based route',
            });
        }
        if (!controllerCtor) {
            throw new assert_1.AssertionError({
                message: 'controller is required for a controller-based route',
            });
        }
        if (!methodName) {
            throw new assert_1.AssertionError({
                message: 'methodName is required for a controller-based route',
            });
        }
        return this.route(new routing_table_1.ControllerRoute(routeOrVerb, path, spec, controllerCtor, controllerFactory, methodName));
    }
    /**
     * Set the OpenAPI specification that defines the REST API schema for this
     * server. All routes, parameter definitions and return types will be defined
     * in this way.
     *
     * Note that this will override any routes defined via decorators at the
     * controller level (this function takes precedent).
     *
     * @param {OpenApiSpec} spec The OpenAPI specification, as an object.
     * @returns {Binding}
     * @memberof RestServer
     */
    api(spec) {
        return this.bind(keys_1.RestBindings.API_SPEC).to(spec);
    }
    /**
     * Get the OpenAPI specification describing the REST API provided by
     * this application.
     *
     * This method merges operations (HTTP endpoints) from the following sources:
     *  - `app.api(spec)`
     *  - `app.controller(MyController)`
     *  - `app.route(route)`
     *  - `app.route('get', '/greet', operationSpec, MyController, 'greet')`
     */
    getApiSpec() {
        const spec = this.getSync(keys_1.RestBindings.API_SPEC);
        const defs = this.httpHandler.getApiDefinitions();
        // Apply deep clone to prevent getApiSpec() callers from
        // accidentally modifying our internal routing data
        spec.paths = cloneDeep(this.httpHandler.describeApiPaths());
        if (defs) {
            spec.components = spec.components || {};
            spec.components.schemas = cloneDeep(defs);
        }
        return spec;
    }
    /**
     * Configure a custom sequence class for handling incoming requests.
     *
     * ```ts
     * class MySequence implements SequenceHandler {
     *   constructor(
     *     @inject('send) public send: Send)) {
     *   }
     *
     *   public async handle({response}: RequestContext) {
     *     send(response, 'hello world');
     *   }
     * }
     * ```
     *
     * @param value The sequence to invoke for each incoming request.
     */
    sequence(value) {
        this.bind(keys_1.RestBindings.SEQUENCE).toClass(value);
    }
    /**
     * Configure a custom sequence function for handling incoming requests.
     *
     * ```ts
     * app.handler(({request, response}, sequence) => {
     *   sequence.send(response, 'hello world');
     * });
     * ```
     *
     * @param handlerFn The handler to invoke for each incoming request.
     */
    handler(handlerFn) {
        let SequenceFromFunction = class SequenceFromFunction extends sequence_1.DefaultSequence {
            // NOTE(bajtos) Unfortunately, we have to duplicate the constructor
            // in order for our DI/IoC framework to inject constructor arguments
            constructor(findRoute, parseParams, invoke, send, reject) {
                super(findRoute, parseParams, invoke, send, reject);
                this.findRoute = findRoute;
                this.parseParams = parseParams;
                this.invoke = invoke;
                this.send = send;
                this.reject = reject;
            }
            async handle(context) {
                await Promise.resolve(handlerFn(context, this));
            }
        };
        SequenceFromFunction = __decorate([
            __param(0, context_1.inject(SequenceActions.FIND_ROUTE)),
            __param(1, context_1.inject(SequenceActions.PARSE_PARAMS)),
            __param(2, context_1.inject(SequenceActions.INVOKE_METHOD)),
            __param(3, context_1.inject(SequenceActions.SEND)),
            __param(4, context_1.inject(SequenceActions.REJECT)),
            __metadata("design:paramtypes", [Function, Function, Function, Function, Function])
        ], SequenceFromFunction);
        this.sequence(SequenceFromFunction);
    }
    /**
     * Start this REST API's HTTP/HTTPS server.
     *
     * @returns {Promise<void>}
     * @memberof RestServer
     */
    async start() {
        // Setup the HTTP handler so that we can verify the configuration
        // of API spec, controllers and routes at startup time.
        this._setupHandlerIfNeeded();
        const port = await this.get(keys_1.RestBindings.PORT);
        const host = await this.get(keys_1.RestBindings.HOST);
        const protocol = await this.get(keys_1.RestBindings.PROTOCOL);
        const httpsOptions = await this.get(keys_1.RestBindings.HTTPS_OPTIONS);
        const serverOptions = {};
        if (protocol === 'https')
            Object.assign(serverOptions, httpsOptions);
        Object.assign(serverOptions, { port, host, protocol });
        this._httpServer = new http_server_1.HttpServer(this.requestHandler, serverOptions);
        await this._httpServer.start();
        this.bind(keys_1.RestBindings.PORT).to(this._httpServer.port);
        this.bind(keys_1.RestBindings.HOST).to(this._httpServer.host);
        this.bind(keys_1.RestBindings.URL).to(this._httpServer.url);
        debug('RestServer listening at %s', this._httpServer.url);
    }
    /**
     * Stop this REST API's HTTP/HTTPS server.
     *
     * @returns {Promise<void>}
     * @memberof RestServer
     */
    async stop() {
        // Kill the server instance.
        if (!this._httpServer)
            return;
        await this._httpServer.stop();
        this._httpServer = undefined;
    }
    _onUnhandledError(req, res, err) {
        if (!res.headersSent) {
            res.statusCode = 500;
            res.end();
        }
        // It's the responsibility of the Sequence to handle any errors.
        // If an unhandled error escaped, then something very wrong happened
        // and it's best to crash the process immediately.
        process.nextTick(() => {
            throw err;
        });
    }
};
RestServer = __decorate([
    __param(0, context_1.inject(core_1.CoreBindings.APPLICATION_INSTANCE)),
    __param(1, context_1.inject(keys_1.RestBindings.CONFIG)),
    __metadata("design:paramtypes", [core_1.Application, Object])
], RestServer);
exports.RestServer = RestServer;
//# sourceMappingURL=rest.server.js.map