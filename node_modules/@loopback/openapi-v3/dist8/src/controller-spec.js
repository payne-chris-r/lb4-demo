"use strict";
// Copyright IBM Corp. 2018. All Rights Reserved.
// Node module: @loopback/openapi-v3
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
const repository_json_schema_1 = require("@loopback/repository-json-schema");
const keys_1 = require("./keys");
const json_to_schema_1 = require("./json-to-schema");
const _ = require("lodash");
const debug = require('debug')('loopback:openapi3:metadata');
/**
 * Build the api spec from class and method level decorations
 * @param constructor Controller class
 */
function resolveControllerSpec(constructor) {
    debug(`Retrieving OpenAPI specification for controller ${constructor.name}`);
    let spec = context_1.MetadataInspector.getClassMetadata(keys_1.OAI3Keys.CLASS_KEY, constructor);
    if (spec) {
        debug('  using class-level spec defined via @api()', spec);
        spec = context_1.DecoratorFactory.cloneDeep(spec);
    }
    else {
        spec = { paths: {} };
    }
    let endpoints = context_1.MetadataInspector.getAllMethodMetadata(keys_1.OAI3Keys.METHODS_KEY, constructor.prototype) || {};
    endpoints = context_1.DecoratorFactory.cloneDeep(endpoints);
    for (const op in endpoints) {
        debug('  processing method %s', op);
        const endpoint = endpoints[op];
        const verb = endpoint.verb;
        const path = endpoint.path;
        let endpointName = '';
        /* istanbul ignore if */
        if (debug.enabled) {
            const className = constructor.name || '<AnonymousClass>';
            const fullMethodName = `${className}.${op}`;
            endpointName = `${fullMethodName} (${verb} ${path})`;
        }
        let operationSpec = endpoint.spec;
        if (!operationSpec) {
            // The operation was defined via @operation(verb, path) with no spec
            operationSpec = {
                responses: {},
            };
            endpoint.spec = operationSpec;
        }
        debug('  operation for method %s: %j', op, endpoint);
        debug('  processing parameters for method %s', op);
        let params = context_1.MetadataInspector.getAllParameterMetadata(keys_1.OAI3Keys.PARAMETERS_KEY, constructor.prototype, op);
        debug('  parameters for method %s: %j', op, params);
        if (params != null) {
            params = context_1.DecoratorFactory.cloneDeep(params);
            /**
             * If a controller method uses dependency injection, the parameters
             * might be sparsed. For example,
             * ```ts
             * class MyController {
             *   greet(
             *     @inject('prefix') prefix: string,
             *     @param.query.string('name) name: string) {
             *      return `${prefix}`, ${name}`;
             *   }
             * ```
             */
            operationSpec.parameters = params.filter(p => p != null).map(p => {
                // Per OpenAPI spec, `required` must be `true` for path parameters
                if (p.in === 'path') {
                    p.required = true;
                }
                return p;
            });
        }
        debug('  processing requestBody for method %s', op);
        let requestBodies = context_1.MetadataInspector.getAllParameterMetadata(keys_1.OAI3Keys.REQUEST_BODY_KEY, constructor.prototype, op);
        if (requestBodies != null)
            requestBodies = requestBodies.filter(p => p != null);
        let requestBody;
        if (requestBodies) {
            if (requestBodies.length > 1)
                throw new Error('An operation should only have one parameter decorated by @requestBody');
            requestBody = requestBodies[0];
            debug('  requestBody for method %s: %j', op, requestBody);
            if (requestBody) {
                operationSpec.requestBody = requestBody;
            }
        }
        operationSpec['x-operation-name'] = op;
        if (!spec.paths[path]) {
            spec.paths[path] = {};
        }
        if (spec.paths[path][verb]) {
            // Operations from subclasses override those from the base
            debug(`  Overriding ${endpointName} - endpoint was already defined`);
        }
        debug(`  adding ${endpointName}`, operationSpec);
        spec.paths[path][verb] = operationSpec;
        debug(`  inferring schema object for method %s`, op);
        const opMetadata = context_1.MetadataInspector.getDesignTypeForMethod(constructor.prototype, op);
        const paramTypes = opMetadata.parameterTypes;
        const isComplexType = (ctor) => !_.includes([String, Number, Boolean, Array, Object], ctor);
        for (const p of paramTypes) {
            if (isComplexType(p)) {
                if (!spec.components) {
                    spec.components = {};
                }
                if (!spec.components.schemas) {
                    spec.components.schemas = {};
                }
                if (p.name in spec.components.schemas) {
                    // Preserve user-provided definitions
                    debug('    skipping parameter type %j as already defined', p.name || p);
                    continue;
                }
                const jsonSchema = repository_json_schema_1.getJsonSchema(p);
                const openapiSchema = json_to_schema_1.jsonToSchemaObject(jsonSchema);
                const outputSchemas = spec.components.schemas;
                if (openapiSchema.definitions) {
                    for (const key in openapiSchema.definitions) {
                        // Preserve user-provided definitions
                        if (key in outputSchemas)
                            continue;
                        const relatedSchema = openapiSchema.definitions[key];
                        debug('    defining referenced schema for %j: %j', key, relatedSchema);
                        outputSchemas[key] = relatedSchema;
                    }
                    delete openapiSchema.definitions;
                }
                debug('    defining schema for %j: %j', p.name, openapiSchema);
                outputSchemas[p.name] = openapiSchema;
                break;
            }
        }
    }
    return spec;
}
/**
 * Get the controller spec for the given class
 * @param constructor Controller class
 */
function getControllerSpec(constructor) {
    let spec = context_1.MetadataInspector.getClassMetadata(keys_1.OAI3Keys.CONTROLLER_SPEC_KEY, constructor, { ownMetadataOnly: true });
    if (!spec) {
        spec = resolveControllerSpec(constructor);
        context_1.MetadataInspector.defineMetadata(keys_1.OAI3Keys.CONTROLLER_SPEC_KEY.key, spec, constructor);
    }
    return spec;
}
exports.getControllerSpec = getControllerSpec;
//# sourceMappingURL=controller-spec.js.map