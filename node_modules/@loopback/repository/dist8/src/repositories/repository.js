"use strict";
// Copyright IBM Corp. 2017,2018. All Rights Reserved.
// Node module: @loopback/repository
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Repository implementation
 *
 * Example:
 *
 * User can import `CrudRepositoryImpl` and call its functions like:
 * `CrudRepositoryImpl.find(somefilters, someoptions)`
 *
 * Or extend class `CrudRepositoryImpl` and override its functions:
 * ```ts
 * export class TestRepository extends CrudRepositoryImpl<Test> {
 *   constructor(dataSource: DataSource, model: Test) {
 *     super(dataSource, Customer);
 *   }
 *
 *   // Override `deleteAll` to disable the operation
 *   deleteAll(where?: Where, options?: Options) {
 *     return Promise.reject(new Error('deleteAll is disabled'));
 *   }
 * }
 * ```
 */
class CrudRepositoryImpl {
    constructor(dataSource, model) {
        this.dataSource = dataSource;
        this.model = model;
        this.connector = dataSource.connector;
    }
    toModels(data) {
        return data.then(items => items.map(i => new this.model(i)));
    }
    toModel(data) {
        return data.then(d => new this.model(d));
    }
    create(entity, options) {
        return this.toModel(this.connector.create(this.model, entity, options));
    }
    createAll(entities, options) {
        return this.toModels(this.connector.createAll(this.model, entities, options));
    }
    save(entity, options) {
        if (typeof this.connector.save === 'function') {
            return this.toModel(this.connector.save(this.model, entity, options));
        }
        else {
            const id = this.model.getIdOf(entity);
            if (id != null) {
                return this.replaceById(id, entity, options).then((result) => result
                    ? this.toModel(Promise.resolve(entity))
                    : Promise.reject(new Error('Not found')));
            }
            else {
                return this.create(entity, options);
            }
        }
    }
    find(filter, options) {
        return this.toModels(this.connector.find(this.model, filter, options));
    }
    findById(id, options) {
        if (typeof this.connector.findById === 'function') {
            return this.toModel(this.connector.findById(this.model, id, options));
        }
        const where = this.model.buildWhereForId(id);
        return this.connector
            .find(this.model, { where: where }, options)
            .then((entities) => {
            return entities[0];
        });
    }
    update(entity, options) {
        return this.updateById(this.model.getIdOf(entity), entity, options);
    }
    delete(entity, options) {
        return this.deleteById(this.model.getIdOf(entity), options);
    }
    updateAll(data, where, options) {
        return this.connector.updateAll(this.model, data, where, options);
    }
    updateById(id, data, options) {
        if (typeof this.connector.updateById === 'function') {
            return this.connector.updateById(this.model, id, data, options);
        }
        const where = this.model.buildWhereForId(id);
        return this.updateAll(data, where, options).then((count) => count > 0);
    }
    replaceById(id, data, options) {
        if (typeof this.connector.replaceById === 'function') {
            return this.connector.replaceById(this.model, id, data, options);
        }
        // FIXME: populate inst with all properties
        // tslint:disable-next-line:no-unused-variable
        const inst = data;
        const where = this.model.buildWhereForId(id);
        return this.updateAll(data, where, options).then((count) => count > 0);
    }
    deleteAll(where, options) {
        return this.connector.deleteAll(this.model, where, options);
    }
    deleteById(id, options) {
        if (typeof this.connector.deleteById === 'function') {
            return this.connector.deleteById(this.model, id, options);
        }
        else {
            const where = this.model.buildWhereForId(id);
            return this.deleteAll(where, options).then((count) => count > 0);
        }
    }
    count(where, options) {
        return this.connector.count(this.model, where, options);
    }
    exists(id, options) {
        if (typeof this.connector.exists === 'function') {
            return this.connector.exists(this.model, id, options);
        }
        else {
            const where = this.model.buildWhereForId(id);
            return this.count(where, options).then(result => result > 0);
        }
    }
    execute(command, parameters, options) {
        if (typeof this.connector.execute !== 'function') {
            throw new Error('Not implemented');
        }
        return this.connector.execute(command, parameters, options);
    }
}
exports.CrudRepositoryImpl = CrudRepositoryImpl;
//# sourceMappingURL=repository.js.map