import { AnyObject } from './common-types';
/**
 * Operators for where clauses
 */
export declare enum Operators {
    eq = 0,
    neq = 1,
    gt = 2,
    gte = 3,
    lt = 4,
    lte = 5,
    inq = 6,
    between = 7,
    exists = 8,
    and = 9,
    or = 10
}
/**
 * Matching condition
 */
export interface Condition {
    eq?: any;
    neq?: any;
    gt?: any;
    gte?: any;
    lt?: any;
    lte?: any;
    inq?: any[];
    between?: any[];
    exists?: boolean;
    and?: Where[];
    or?: Where[];
}
/**
 * Where object
 *
 * Examples:
 * `{afieldname: 'aName'}`
 * `{and: [{fieldone: 'one'}, {fieldtwo: 'two'}]}`
 * `{or: [{fieldone: 'one'}, {fieldtwo: 'two'}]}`
 */
export interface Where {
    and?: Where[];
    or?: Where[];
    [property: string]: Condition | any;
}
/**
 * Order by direction
 */
export declare type Direction = 'ASC' | 'DESC';
/**
 * Order by
 *
 * Example:
 * `{afieldname: 'ASC'}`
 */
export interface Order {
    [property: string]: Direction;
}
/**
 * Selection of fields
 *
 * Example:
 * `{afieldname: true}`
 */
export interface Fields {
    [property: string]: boolean;
}
/**
 * Inclusion of related items
 *
 * Note: scope means filter on related items
 *
 * Example:
 * `{relation: 'aRelationName', scope: {<AFilterObject>}}`
 */
export interface Inclusion {
    relation: string;
    scope?: Filter;
}
/**
 * Query filter object
 */
export interface Filter {
    /**
     * The matching criteria
     */
    where?: Where;
    /**
     * To include/exclude fields
     */
    fields?: Fields;
    /**
     * Sorting order for matched entities. Each item should be formatted as
     * `fieldName ASC` or `fieldName DESC`.
     * For example: `['f1 ASC', 'f2 DESC', 'f3 ASC']`.
     *
     * We might want to use `Order` in the future. Keep it as `string[]` for now
     * for compatibility with LoopBack 3.x.
     */
    order?: string[];
    /**
     * Maximum number of entities
     */
    limit?: number;
    /**
     * Skip N number of entities
     */
    skip?: number;
    /**
     * Offset N number of entities. An alias for `skip`
     */
    offset?: number;
    /**
     * To include related objects
     */
    include?: Inclusion[];
}
export declare function isFilter(arg: any): arg is Filter;
/**
 * A builder for Where object. It provides fleunt APIs to add clauses such as
 * `and`, `or`, and other operators.
 *
 * @example
 * ```ts
 * const whereBuilder = new WhereBuilder();
 * const where = whereBuilder
 *   .eq('a', 1)
 *   .and({x: 'x'}, {y: {gt: 1}})
 *   .and({b: 'b'}, {c: {lt: 1}})
 *   .or({d: 'd'}, {e: {neq: 1}})
 *   .build();
 * ```
 */
export declare class WhereBuilder {
    where: Where;
    constructor(w?: Where);
    private add;
    /**
     * Add an `and` clause.
     * @param w One or more where objects
     */
    and(...w: (Where | Where[])[]): this;
    /**
     * Add an `or` clause.
     * @param w One or more where objects
     */
    or(...w: (Where | Where[])[]): this;
    /**
     * Add an `=` condition
     * @param key Property name
     * @param val Property value
     */
    eq(key: string, val: any): this;
    /**
     * Add a `!=` condition
     * @param key Property name
     * @param val Property value
     */
    neq(key: string, val: any): this;
    /**
     * Add a `>` condition
     * @param key Property name
     * @param val Property value
     */
    gt(key: string, val: any): this;
    /**
     * Add a `>=` condition
     * @param key Property name
     * @param val Property value
     */
    gte(key: string, val: any): this;
    /**
     * Add a `<` condition
     * @param key Property name
     * @param val Property value
     */
    lt(key: string, val: any): this;
    /**
     * Add a `<=` condition
     * @param key Property name
     * @param val Property value
     */
    lte(key: string, val: any): this;
    /**
     * Add a `inq` condition
     * @param key Property name
     * @param val An array of property values
     */
    inq(key: string, val: any[]): this;
    /**
     * Add a `between` condition
     * @param key Property name
     * @param val1 Property value lower bound
     * @param val2 Property value upper bound
     */
    between(key: string, val1: any, val2: any): this;
    /**
     * Add a `exists` condition
     * @param key Property name
     * @param val Exists or not
     */
    exists(key: string, val?: boolean): this;
    /**
     * Add a where object. For conflicting keys with the existing where object,
     * create an `and` clause.
     * @param where Where filter
     */
    impose(where: Where): this;
    /**
     * Get the where object
     */
    build(): Where;
}
/**
 * A builder for Filter. It provides fleunt APIs to add clauses such as
 * `fields`, `order`, `where`, `limit`, `offset`, and `include`.
 *
 * @example
 * ```ts
 * const filterBuilder = new FilterBuilder();
 * const filter = filterBuilder
 *   .fields('id', a', 'b')
 *   .limit(10)
 *   .offset(0)
 *   .order(['a ASC', 'b DESC'])
 *   .where({id: 1})
 *   .build();
 * ```
 */
export declare class FilterBuilder {
    filter: Filter;
    constructor(f?: Filter);
    /**
     * Set `limit`
     * @param limit Maximum number of records to be returned
     */
    limit(limit: number): this;
    /**
     * Set `offset`
     * @param offset Offset of the number of records to be returned
     */
    offset(offset: number): this;
    /**
     * Alias to `offset`
     * @param skip
     */
    skip(skip: number): this;
    /**
     * Describe what fields to be included/excluded
     * @param f A field name to be included, an array of field names to be
     * included, or an Fields object for the inclusion/exclusion
     */
    fields(...f: (Fields | string[] | string)[]): this;
    private validateOrder;
    /**
     * Describe the sorting order
     * @param f A field name with optional direction, an array of field names,
     * or an Order object for the field/direction pairs
     */
    order(...o: (string | string[] | Order)[]): this;
    /**
     * Declare `include`
     * @param i A relation name, an array of relation names, or an `Inclusion`
     * object for the relation/scope definitions
     */
    include(...i: (string | string[] | Inclusion)[]): this;
    /**
     * Declare a where clause
     * @param w Where object
     */
    where(w: Where): this;
    /**
     * Add a Filter or Where constraint object. If it is a filter object, create
     * an `and` clause for conflicting keys with its where object. For any other
     * properties, throw an error. If it's not a Filter, coerce it to a filter,
     * and carry out the same logic.
     *
     * @param constraint a constraint object to merge with own filter object
     */
    impose(constraint: Filter | Where): this;
    /**
     * Return the filter object
     */
    build(): Filter;
}
export declare function filterTemplate(strings: TemplateStringsArray, ...keys: any[]): (ctx: AnyObject) => any;
