import { MetadataMap, MetadataAccessor } from '@loopback/context';
import { ModelDefinition, ModelDefinitionSyntax, PropertyDefinition } from '../model';
import { RelationDefinitionBase } from './relation.decorator';
export declare const MODEL_KEY: MetadataAccessor<Partial<ModelDefinitionSyntax>, ClassDecorator>;
export declare const MODEL_PROPERTIES_KEY: MetadataAccessor<PropertyDefinition, PropertyDecorator>;
export declare const MODEL_WITH_PROPERTIES_KEY: MetadataAccessor<ModelDefinition, ClassDecorator>;
export declare type PropertyMap = MetadataMap<PropertyDefinition>;
export declare type RelationMap = MetadataMap<RelationDefinitionBase>;
/**
 * Decorator for model definitions
 * @param definition
 * @returns {(target:any)}
 */
export declare function model(definition?: Partial<ModelDefinitionSyntax>): (target: Function & {
    definition?: ModelDefinition | undefined;
}) => void;
/**
 * Decorator for model properties
 * @param definition
 * @returns {(target:any, key:string)}
 */
export declare function property(definition?: Partial<PropertyDefinition>): PropertyDecorator;
export declare namespace property {
    const ERR_PROP_NOT_ARRAY = "@property.array can only decorate array properties!";
    const ERR_NO_ARGS = "decorator received less than two parameters";
    /**
     *
     * @param itemType The class of the array to decorate
     * @param definition Optional PropertyDefinition object for additional
     * metadata
     */
    function array(itemType: Function, definition?: Partial<PropertyDefinition>): (target: Object, propertyName: string) => void;
}
