"use strict";
// Copyright IBM Corp. 2017,2018. All Rights Reserved.
// Node module: @loopback/repository
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
const model_1 = require("../model");
const relation_decorator_1 = require("./relation.decorator");
exports.MODEL_KEY = context_1.MetadataAccessor.create('loopback:model');
exports.MODEL_PROPERTIES_KEY = context_1.MetadataAccessor.create('loopback:model-properties');
exports.MODEL_WITH_PROPERTIES_KEY = context_1.MetadataAccessor.create('loopback:model-and-properties');
// tslint:disable:no-any
/**
 * Decorator for model definitions
 * @param definition
 * @returns {(target:any)}
 */
function model(definition) {
    return function (target) {
        definition = definition || {};
        const def = Object.assign(definition, {
            name: definition.name || target.name,
        });
        const decorator = context_1.ClassDecoratorFactory.createDecorator(exports.MODEL_KEY, definition);
        decorator(target);
        // Build "ModelDefinition" and store it on model constructor
        const modelDef = new model_1.ModelDefinition(def);
        const propertyMap = context_1.MetadataInspector.getAllPropertyMetadata(exports.MODEL_PROPERTIES_KEY, target.prototype) || {};
        for (const p in propertyMap) {
            const propertyDef = propertyMap[p];
            const designType = context_1.MetadataInspector.getDesignTypeForProperty(target.prototype, p);
            if (!propertyDef.type) {
                propertyDef.type = designType;
            }
            modelDef.addProperty(p, propertyDef);
        }
        target.definition = modelDef;
        const relationMap = context_1.MetadataInspector.getAllPropertyMetadata(relation_decorator_1.RELATIONS_KEY, target.prototype) || {};
        target.definition.relations = relationMap;
    };
}
exports.model = model;
/**
 * Decorator for model properties
 * @param definition
 * @returns {(target:any, key:string)}
 */
function property(definition) {
    return context_1.PropertyDecoratorFactory.createDecorator(exports.MODEL_PROPERTIES_KEY, Object.assign({}, definition));
}
exports.property = property;
(function (property) {
    property.ERR_PROP_NOT_ARRAY = '@property.array can only decorate array properties!';
    property.ERR_NO_ARGS = 'decorator received less than two parameters';
    /**
     *
     * @param itemType The class of the array to decorate
     * @param definition Optional PropertyDefinition object for additional
     * metadata
     */
    function array(itemType, definition) {
        return function (target, propertyName) {
            const propType = context_1.MetadataInspector.getDesignTypeForProperty(target, propertyName);
            if (propType !== Array) {
                throw new Error(property.ERR_PROP_NOT_ARRAY);
            }
            else {
                property(Object.assign({ type: Array, itemType }, definition))(target, propertyName);
            }
        };
    }
    property.array = array;
})(property = exports.property || (exports.property = {}));
//# sourceMappingURL=model.decorator.js.map